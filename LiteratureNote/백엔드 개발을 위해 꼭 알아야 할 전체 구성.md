# 백엔드 개발을 위해 꼭 알아야 할 전체 구성
https://www.youtube.com/watch?v=M8E6vYAIuzQ

## **핵심 요약: “백엔드 기초 = 웹서버 / WAS / 데이터베이스 3요소”**

  

이 영상은 백엔드의 본질을 “유저에게 데이터를 **안정적으로 전달**하는 구조”로 보고, 그 핵심을 딱 3가지 구성요소로 압축합니다.

- **웹서버(Web Server)**: 정적 파일(HTML/CSS/JS/이미지)을 **빠르고 효율적으로 전달**
    
- **WAS(Web Application Server)**: 요청에 따라 **코드를 실행**해서 동적 결과(JSON/HTML)를 만들어 전달
    
- **데이터베이스(Database)**: 데이터를 **영속적으로 저장**하고, **동시성/무결성/검색 성능**을 보장
    

---

## **1) 웹서버: “정적 파일 전달의 최적화”**

  

### **왜 생겼나?**

  

초기 WWW는 “문서 공유”가 목적이라, 요청이 오면 **저장된 HTML 파일을 그대로 전송**하는 역할이 필요했음.

  

### **하는 일**

- 브라우저가 화면을 그릴 수 있도록 **정적 리소스**를 전달
    
- **항상 같은 결과**를 반환(사용자/시간에 따라 내용이 바뀌지 않음 → 정적 웹)
    

  

### **대표 예시**

- Nginx, Apache, IIS, Caddy 등
    

---

## **2) WAS: “동적 요청 처리 엔진(=백엔드의 시작)”**

  

### **왜 생겼나?**

  

사람들이 “방문자수, 로그인, 글쓰기, 사용자별 화면”처럼 **요청마다 다른 결과(동적 컨텐츠)** 를 원하기 시작했는데, 웹서버만으로는 불가능했음.

  

### **하는 일**

- HTTP 요청을 받아 **해석 → 코드 실행 → 결과 생성**
    
- 결과를 JSON/HTML 등으로 만들어 응답
    

  

### **웹서버 vs WAS 차이(핵심)**

- **웹서버**: 정적(항상 같은 파일/리소스)
    
- **WAS**: 동적(요청 파라미터/인증/비즈니스 로직에 따라 결과가 바뀜)
    

---

## **3) WAS vs 백엔드 프레임워크(면접 단골 포인트)**

  

영상에서 강조하는 핵심 구분:

- **백엔드 프레임워크(Spring/Django/FastAPI/Express 등)**
    
    → “비즈니스 로직을 만들기 위한 **설계도 + 부품세트**”
    
- **WAS**
    
    → 그 설계도로 만든 코드를 실제로 실행하는 **런타임/엔진**
    

  

### **동작 흐름(영상의 설명을 구조로 정리)**

1. 클라이언트가 HTTP 요청 전송
    
2. **WAS가 HTTP 패킷을 파싱**해서 Request 객체 생성
    
3. Request를 **프레임워크**에 전달
    
4. 프레임워크가 라우팅/컨트롤러 실행 → 결과 생성
    
5. 결과를 Response 객체로 만들어 WAS에 반환
    
6. WAS가 다시 HTTP 응답으로 변환해 클라이언트로 전송
    

  

### **“난 WAS 설치 안 했는데요?”에 대한 답**

  

요즘은 프레임워크가 **내장 서버(내장 WAS)를 포함**하는 경우가 많아서 그렇게 느껴짐.

- Spring Boot: 내장 Tomcat 포함
    
- Node.js: 런타임 자체가 HTTP 처리까지 수행(미니 WAS 역할), Express는 그 위에서 라우팅/미들웨어 담당
    

---

## **4) 데이터베이스: “파일 저장으로 못 푸는 3가지 문제”**

  

### **왜 생겼나?**

  

WAS로 동적 페이지는 만들 수 있는데, 서버를 껐다 켜면 데이터가 날아감.

게다가 웹이 커지면서 **안전한 저장/동시 접근/정확성/성능**이 필요해짐.

  

### **“그냥 파일에 저장하면 안 돼요?”에 대한 답**

  

파일 시스템만으로는 치명적인 3가지가 어렵다고 정리함:

1. **동시성 제어(레이스 컨디션)**
    
    - 동시에 구매 버튼 누르면 “재고 1개” 같은 상황이 깨짐
        
    - DB는 락 등의 메커니즘으로 일관성 유지
        
    
2. **무결성(트랜잭션)**
    
    - 계좌이체처럼 “둘 다 성공 or 둘 다 실패”가 보장돼야 함(원자성)
        
    
3. **검색 성능(인덱스)**
    
    - 대용량 파일은 순차 탐색이라 느림
        
    - DB는 인덱스로 빠른 탐색 제공
        
    

---

## **5) 3요소가 실제로 협력하는 흐름(로그인/게시글 예시)**

  

### **(1) 홈페이지 접속**

- 브라우저 → 웹서버
    
- 웹서버가 **정적 파일(프론트엔드 리소스)** 전송
    
- 브라우저가 화면 렌더링(하지만 데이터는 아직 비어있을 수 있음)
    

  

### **(2) 로그인 요청**

- 프론트엔드가 /api/login 같은 API 요청 전송
    
- 웹서버는 “API 요청이네?” → **WAS로 프록시 전달**
    
- WAS는 DB 조회로 사용자 검증 → 성공 시 JWT 생성 → JSON 응답 반환
    

  

### **(3) 게시글 조회**

- 프론트엔드가 인증 토큰 포함해서 /api/posts/123 요청
    
- 웹서버 → WAS 프록시
    
- WAS가 토큰 검증 후 DB에서 게시글 조회
    
- WAS가 JSON 가공 → 웹서버 경유 → 브라우저
    
- 프론트엔드가 받은 JSON으로 화면 구성
    

---

## **최종 결론(영상의 메시지)**

- 백엔드의 발전 = “웹이 복잡해지며 생긴 문제를 역할 분리로 해결한 역사”
    
- **웹서버(정적 전달)** → **WAS(동적 처리)** → **DB(안전한 데이터 관리)**
    
    이 3개만 정확히 잡으면, 그 위의 모니터링/로드밸런싱/캐싱/CI/CD/쿠버네티스 같은 것들이 “어디에 왜 붙는지”가 자연스럽게 보인다는 주장입니다.
    

---

## **키워드 (최대 3개)**

- **웹서버**
    
- **WAS**
    
- **데이터베이스**