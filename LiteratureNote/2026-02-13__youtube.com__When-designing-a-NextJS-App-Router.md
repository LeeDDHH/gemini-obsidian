---
type: literature
source_url: https://www.youtube.com/shorts/rX5b9rGiIww
source_title: When designing a NextJS App Router, remember only "this" #aicoding #frontend
created_at: 2026-02-13
tags: []
---

# When designing a NextJS App Router, remember only "this" #aicoding #frontend

## TL;DR
*   이 노트는 유튜브 Shorts 영상 "When designing a NextJS App Router, remember only "this" #aicoding #frontend"의 내용을 요약합니다.
*   영상은 Next.js App Router 설계 시 기억해야 할 핵심 사항을 다룹니다.
*   AI 시대의 프로덕트 엔지니어 성장 캠프(https://productengineer.info/camp/landing) 관련 정보가 포함되어 있습니다.

## 요약

이 유튜브 Shorts 영상은 Next.js App Router를 설계할 때 반드시 기억해야 할 중요한 '이것'에 대해 다룹니다. 영상 제목에 `#aicoding #frontend` 해시태그가 포함되어 있어, AI 코딩과 프론트엔드 개발의 교차점에서 Next.js App Router의 효율적인 활용 방안에 대한 팁을 제공할 것으로 예상됩니다. 영상 설명에는 "AI 시대, 프로덕트 엔지니어 캠프(https://productengineer.info/camp/landing)에서 함께 성장하세요"라는 문구가 있어, 관련 교육 프로그램에 대한 홍보도 포함되어 있음을 알 수 있습니다. 이 Shorts는 Next.js App Router의 복잡한 구조를 간결하게 요약하여 개발자들이 핵심 원칙을 쉽게 이해하고 적용할 수 있도록 돕는 데 초점을 맞추고 있습니다.

## 핵심 포인트 / 인용
*   **핵심 주장**: Next.js App Router 설계 시 특정 핵심 원칙을 기억하면 효율적인 개발이 가능하다.
*   **근거**: 유튜브 영상의 제목과 설명에서 직접적으로 언급된 내용에 기반하며, AI 시대의 프론트엔드 개발 트렌드를 반영합니다.
*   **리스크**: Shorts 영상의 특성상 내용의 깊이가 제한적일 수 있으며, 설명만으로는 '이것'이 무엇인지 명확히 파악하기 어렵습니다. 실제 영상 시청을 통해 구체적인 정보를 얻어야 합니다.
*   **적용 포인트**: Next.js App Router를 사용하여 프로젝트를 진행하는 프론트엔드 개발자들에게 실용적인 설계 팁을 제공하고, AI 시대에 발맞춰 프로덕트 엔지니어로서의 성장을 독려하는 정보를 전달합니다.

## 메타
*   가져온 시간: 2026-02-13 10:39
*   파서/모드: YouTube video description summary

---

## 요약
- Next.js App Router의 핵심 원칙은 “가능한 한 UI 렌더링과 데이터 패칭을 서버에서 수행한다”는 것.
- 서버에서 처리하면 **클라이언트로 보내는 JS 번들(불필요한 JS)**을 최소화할 수 있고, 이를 원칙으로 삼으면 성능 최적화에 유리해진다.
- 또한 “데이터와 UI 변화 시점을 묶는다”는 말은, 데이터가 바뀌면 UI도 함께 바뀌는 현실을 전제로 도메인 기준으로 응집도를 높인다는 뜻이다.
- 즉, **데이터 패칭/데이터 로직/렌더링(UI 컴포넌트)**은 어차피 함께 변경되기 쉬우므로, 이를 하나의 단위(도메인 단위)로 묶어 관리하는 편이 변화 대응에 더 유연하다.
- 이 설계를 실현하는 대표 수단이 Server Component이며, Server Component 내부에서 fetch + render 로직을 결합해 도메인 단위로 응집시키는 것이 “좋은 설계/좋은 코드”의 기준으로 제시된다.

## 핵심 포인트 정리
- 서버 우선(Server-first): 렌더링/데이터 패칭을 서버로 이동
- JS 전송 최소화: 불필요한 클라이언트 JS 금지 → 번들 감소 → 성능 개선
- 도메인 중심 응집: 데이터 변경 ↔ UI 변경이 함께 일어나는 지점을 기준으로 코드 구조를 묶음
- Server Component의 역할: “fetch와 render 결합”을 자연스럽게 만들고 도메인 단위 응집을 강화

## 키워드 (최대 3개)
- App Router 철학
- Server Components
- 도메인 응집도

---

App Router는 “페이지를 렌더링한다”가 아니라 “요청(request)마다 필요한 UI 트리와 데이터 작업을 조립한다” 쪽에 가까운 철학이에요. Pages Router를 기준으로 멘탈 모델을 갈아타는 포인트만 딱 잡아드릴게요.

1) Pages Router vs App Router: 세계관 한 줄
- Pages Router: 페이지 단위(파일) = 라우트 = 렌더링의 기본 단위
- App Router: 세그먼트(폴더) + 레이아웃 트리 = 라우트의 기본 단위
→ “페이지”보다 **UI 트리(레이아웃/중첩)**가 1급 시민

⸻

2) App Router의 핵심 멘탈 모델 5개

(1) “라우팅은 폴더 트리 = UI 트리”

app/ 아래 폴더 구조가 곧 중첩 레이아웃 구조예요.
- app/layout.tsx : 앱 전체의 뼈대(최상위)
- app/(group)/... : URL에는 안 나오지만 트리는 나뉘는 “그룹”
- app/foo/layout.tsx : /foo 아래 모든 화면이 공유하는 레이아웃
- app/foo/page.tsx : 해당 세그먼트의 “리프 페이지”

결과: “페이지 이동”이라기보다 트리의 일부만 갈아끼우는 리렌더에 가까워져요.

⸻

(2) “기본은 Server Component”

App Router에선 React Server Components가 기본값이에요.
- 기본: 서버에서 렌더/데이터 접근 OK
- 클라이언트에서만 가능한 것(상태, 이벤트, 브라우저 API)은 use client가 필요한 Client Component

멘탈 모델:
“클라이언트에 JS를 더하는 건 opt-in(필요할 때만)”
→ Pages Router의 “기본 CSR/SSR 혼합” 감각과 반대 방향

⸻

(3) “데이터 페칭은 ‘어디서든’ 하지만, 서버가 우선”

Pages Router: getServerSideProps / getStaticProps 같은 “페이지 전용 훅”이 중심
App Router: 컴포넌트(서버 컴포넌트) 안에서 그냥 fetch/DB 호출이 자연스러움

멘탈 모델:
“데이터는 페이지가 아니라 트리의 특정 노드가 책임진다”
→ 레이아웃에서 공통 데이터(유저, 권한, 네비) 가져오고, 하위는 필요한 것만 추가.

⸻

(4) “네비게이션은 ‘문서 이동’이 아니라 ‘세그먼트 패치’”

next/navigation의 라우팅은 단순 push가 아니라,
- 레이아웃은 유지되고
- 바뀌는 세그먼트만 새로 가져와서
- 스트리밍/서스펜스로 UI를 업데이트

멘탈 모델:
SPA처럼 보이지만 내부는 “요청 기반 조립”이 강해요.

⸻

(5) “캐싱/리밸리데이션이 기본 설계의 일부”

App Router는 성능 모델이 캐시를 전제로 설계돼 있어요.
(“언제 동적이고 언제 정적인지”를 설계로 표현하는 쪽)

멘탈 모델:
“이 화면은 매번 계산”이 아니라
“기본은 캐시, 필요하면 동적으로 깨기”

⸻

3) ‘use client’의 사고방식 (가장 헷갈리는 부분)

use client는 “이 컴포넌트부터 아래는 브라우저에서 실행” 선언이에요.
- 위(서버) → 아래(클라이언트)로 내려가는 건 OK
- 아래(클라이언트)에서 위(서버)를 직접 import 하는 건 기본적으로 막힘/비권장

실전 감각:
- 상태/이벤트는 최대한 작은 섬(island) 으로 use client를 최소화
- 레이아웃/데이터/권한은 서버 쪽에 두는 게 App Router 철학과 잘 맞아요

⸻

4) App Router로 갈아탈 때, 머릿속에서 바꿔야 하는 질문들

Pages Router에서 자주 하던 질문 → App Router식 질문
- “이 페이지는 SSR인가?”
→ “이 트리 노드(레이아웃/페이지)는 서버/클라 중 어디인가?”
- “getServerSideProps에서 다 가져오자”
→ “공통 데이터는 상위 레이아웃, 화면별 데이터는 해당 세그먼트”
- “라우트 이동하면 전체가 다시 그려지나?”
→ “어떤 레이아웃은 유지되고 무엇만 교체되나?”

⸻

5) 지금 바로 감 잡는 추천 연습 3개 (Pages Router 경험자용)
1. app/layout.tsx + app/page.tsx만 만들고, 레이아웃이 페이지 이동에도 유지되는지 체감
2. app/dashboard/layout.tsx에서 유저 정보를 가져오고, 하위 page.tsx들은 그걸 “UI만” 쓰게 구성
3. 버튼/폼처럼 상태 필요한 부분만 use client로 쪼개서 “클라 섬 최소화” 연습
