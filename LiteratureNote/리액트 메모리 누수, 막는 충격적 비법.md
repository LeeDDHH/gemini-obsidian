# 리액트 메모리 누수, 막는 충격적 비법
https://www.youtube.com/watch?v=7A0C0tJZ4sQ

## **요약**

- useEffect 안에서 **이벤트 리스너 추가(addEventListener)**, **구독(subscription)** 같은 “외부 연결”을 걸어두면, return () => { ... } 형태의 **클린업(cleanup) 함수에서 반드시 해제(remove / unsubscribe)** 해줘야 합니다.
    
- 이 해제를 안 하면 컴포넌트가 사라졌는데도 리스너/구독이 남아서 **메모리 누수**, **중복 실행(같은 이벤트가 여러 번 호출)**, **예상치 못한 상태 업데이트** 같은 문제가 발생합니다.
    
- useEffect의 return에 있는 클린업은 보통 다음 시점에 실행됩니다:
    
    - 컴포넌트가 **언마운트(unmount)** 될 때
        
    - 같은 effect가 다시 실행되기 직전(의존성 배열 변경으로 인해 **재실행되기 전**)
        
    

  

즉, “설정은 effect 본문에서, 정리는 return에서”가 기본 패턴입니다.

---

## **핵심 포인트**

- **무엇을 정리하나?**
    
    - addEventListener → removeEventListener
        
    - setInterval / setTimeout → clearInterval / clearTimeout
        
    - Observable / WebSocket / store 구독 → unsubscribe / close
        
    - 외부 라이브러리의 핸들러 등록 → 해당 해제 API 호출
        
    
- **왜 return에서 해야 하나?**
    
    - React가 effect의 생명주기를 관리하는 방식상, “effect가 끝날 때” 또는 “다시 걸기 전”에 **정리할 타이밍을 보장**해주는 위치가 바로 return cleanup이기 때문입니다.
        
    

---

## **키워드 (최대 3개)**

- useEffect cleanup
    
- removeEventListener
    
- memory leak